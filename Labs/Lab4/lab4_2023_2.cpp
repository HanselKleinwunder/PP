/*************************************************************
	Практическое занятие №4. Встроенные массивы.
							Простейшие алгоритмы сортировки и поиска.
							
*************************************************************/

#include <cstdlib>
#include <ctime>
#include <iostream>

#define	  stop __asm nop

int main()
//Задания, помеченные * не являются обязательными. Но выполнение их крайне желательно!!!
{
///////////////////////////////////////////////////////////////
//			Указатели (продолжение)                              
///////////////////////////////////////////////////////////////

//Задание 1. Модификатор const. 
//В каждом из заданий объявите указатель требуемого вида. 
//Посредством каждого указателя попробуйте:
//1) получить значение по адресу
//2) записать новое значение по адресу
//3) модифицировать указатель
//Замечания:
//1.операторы явного преобразования типа использовать не следует
//2.если компилятор не позволяет выполнить операцию, то комментируйте эту строку с пояснением

//Задание 1a. Указатель является константой. 
#if 0
	int n = 5;
    int* const pn = &n; //&n	0x0118f79c {5}	int *
	int b = *pn; //Записать в переменную "b" значение указателя можно
	*pn = 6; //Записываем в адрес переменной "n" новое значение
	//p++; // Т.к.это константный указатель, то модифицировать нельзя
#endif
	stop
//Задание 1б. Указываемое значение является константой.
#if 0
	int n = 5;
	const int* pn = &n;
	//*pn = 6; //Ошибка. Нельзя менять значение посредством указателя.
	int b = *pn; //Записать в переменную "b" значение указателя можно
	pn++; //Изменять сам указатель можно, передвигаем его на 1 байт.
#endif
	stop
//Задание 1в. И указатель, и указываемое значение являются константами. 
#if 0
	int n = 5;
	const int* const pn = &n; //Посредством такого указателя можно доставать значения
	//*pn = 6; //Ошибка. Нельзя менять значение посредством указателя.
	int b = *pn; //Записать в переменную "b" значение указателя можно
	//pn++; //Нельзя модифицировать
#endif
	stop
//Задание 1г. Указатель на переменную, объявленную с ключевым словом const.
#if 0

	const int nN = 1;
	//Объявите указатель и проинициализируйте его выражением - &nN
	const int* pn = &nN; //Ошибка. Появилась бы возможность модифицировать константную переменную
	//*pn = 6; 
	pn++;
#endif
	stop
//Задание 1д. const  и void-указатель.
#if 0
	{
		const int n = 1;
//1) Что нужно сделать для того, чтобы следующее закомментированное выражение стало корректным?
		//void* pn = &n;  
		void const* pn = &n;
//2) как получить значение посредством  void* ?
		//void* pn = &n;
		int intP = *static_cast<const int*>(pn);
	}
#endif
	stop
//Задание 1е.
#if 0
//Объявите указатель на тип char и проинициализируйте его адресом строкового литерала.
//Присвойте переменной типа char значение любого элемента строки.
//Проверьте - возможно ли присвоить какое-либо значение по адресу, задаваемому указателем?

	const char* pc = "ABC";
	char a = pc[0];// "A";
	//*pc = 'd';
	//Мы не можем присвоить какое-либо значение. Область памяти строкового литерала защищена от записи
#endif
	stop
// *******************************************************
//Задание 2. Явное преобразование указателя. 
#if 0
//Иногда возникает необходимость одни и те же данные интерпретировать по-разному,
//например, целое можно представить как совокупность четырех
//байтов и работать с каждым байтом по отдельности. Для этого
//нужно иметь возможность "указывать" как на целое, так и на байт. 
//Следовательно, возникает необходимость явного преобразования указателя. 

//Подсказка: для правильной интерпретации этого задания воспользуйтесь
//возможностями отладчика представлять данные в интересующем
//Вас виде (в данном случае - в шестнадцатеричном) - для
//этого используйте правую клавишу мыши,находясь в окне
//переменных и изменяйте пункт - Hexadecimal display !!!!!!!!!!!!!!!!!

	unsigned int nObject5=0x55667788;
	unsigned int* pnObject5=&nObject5;

//Раскомментировав следующую строчку кода, обратите внимание на сообщение компилятора 
//- он не считает преобразование "легальным" (безопасным)

	unsigned char* pucObject5;

//	pucObject5=static_cast<unsigned char*>(pnObject5);	//(1)

	pucObject5=reinterpret_cast<unsigned char*>(pnObject5);	//а такое
//преобразование - целиком на совести программиста.
//Его можно применять, только четко представляя себе
//результат преобразования (2)
//Откомментируйте (!) следующие строчки следующим образом:
// сс=..., 	pucObject5 - изменился? 	*pucObject5=...

	char cc = *(pucObject5++);	//cc	0x88 'ˆ'	char, pucObject5	0x0099f789 "wfUÌÌÌÌ"	unsigned char *
	cc = (*pucObject5)++;		//cc	0x77 'w'	char, pucObject5	0x0099f789 "xfUÌÌÌÌ"	unsigned char *

	cc = ++*(pucObject5);		//cc	0x79 'y'	char, pucObject5	0x0099f789 "yfUÌÌÌÌ"	unsigned char *
	cc = *(++pucObject5);		//cc	0x66 'f'	char, pucObject5	0x0099f78a "fUÌÌÌÌ"		unsigned char *
#endif
	stop
///////////////////////////////////////////////////////////////
//			Встроенные массивы                               
///////////////////////////////////////////////////////////////

// *******************************************************
//Задание 3. 
#if 0
//Имеется одномерный встроенный массив, проинициализированный при объявлении 
//Отсортируйте массив по возрастанию значений. 
//Используйте "пузырьковую" сортировку  
//Правильность решения проверьте с помощью отладчика

{
	int ar[] = { 5, 4, 7, 8, 1, 2, 6, 0, 10, 12, 77, 11,
					  6, 8, 33, 21, 1, 2, 3, 4};
	int temp = 0;
	int n = sizeof(ar) / sizeof(ar[0]);

	for (int i = 0; i < n; i++) 
	{
		for (int j = 0; j < n - 1; j++) 
		{
			if (ar[j + 1] < ar[j]) 
			{
				temp = ar[j + 1];
				ar[j + 1] = ar[j];
				ar[j] = temp;
			}
		}
	}
	for (int k = 0; k < sizeof(ar) / sizeof(ar[0]); k++)
	{
		std::cout << ar[k] << " ";
	}
	}
#endif
	stop
// *******************************************************
//Задание 4  
#if 0
//в)Инициализация массива строковыми литералами:
//Объявите одномерный массив УКАЗАТЕЛЕЙ и проинициализируйте его СТРОКОВЫМИ литералами . 
//Выведите  массив на печать.

	const char* arr[] = { "A","B","C" };
	for (int i = 0; i < sizeof(arr)/sizeof(arr[0]); i++)
	{
		std::cout << arr[i] << "";
	}
#endif
	stop
// *******************************************************
//Задание 5. 
#if 0
//a) Объявите одномерный неинициализированный массив ( размером N)
//Задайте значения элементов с помощью генератора случайных чисел.

//Подсказка 1: для генерации случайных чисел используйте функцию
//стандартной библиотеки - rand() (<cstdlib>)
// int tmp= rand(); // получим случайное значение в диапазоне от 0 до RAND_MAX
//значение RAND_MAX задано в файле <stdlib.h>  и равно  0x7fff

//если Вам требуется задать иные границы диапазона при генерации случайного числа, 
//то это можно сделать так:
//v1 = rand() % 100;         // v1 в диапазоне 0 - 99
//v2 = rand() % 100 + 1;     // v2 в диапазоне 1 - 100
//v3 = rand() % 30 + 1985;   // v3 в диапазоне 1985-2014 

//Подсказка 2: На самом деле те значения, которые создаются генератором случайных
//чисел являются "псевдослучайными", то есть при двух последовательных запусках
//приложения Вы получаете две одинаковые последовательности значений.
//Для того чтобы генерируемые "случайные" значения были разными при каждом 
//запуске приложения используйте функции стандартной библиотеки srand() (<cstdlib>)
//и time() (<ctime>).
//Функция srand() осуществляет "привязку" начала генерации к указанному в качестве параметра значению.
//Функция time() задает эту точку отсчета, считывая текущее время
//srand( time( 0 ) );
//(Подсказки в файле Алгоритмы для лабораторной работы_4. pdf)


//б) Выведите массив на печать

//в)Отсортируйте массив по убыванию значений. 
//Используйте сортировку "выбором"
	{
	srand(time(0));
	//a объявление одномерного массива на 10 элементов
	const int N = 10;
	int arr[N];
	int temp = 0;

	for (size_t i = 0; i < 10; i++)
	{
		arr[i] = rand() % 101;
	}
	//b вывод массива на печать
	std::cout << "No sorting: ";

	for (size_t j = 0; j < sizeof(arr) / sizeof(arr[0]); j++)
	{
		std::cout << arr[j] << " ";
	}
	//c сортировка по убыванию. Используется алгоритм сортировки "выбором"
	for (size_t k = 0; k < sizeof(arr) / sizeof(arr[0]) - 1; k++)
	{
		int indexMax = k;//запоминаем индекс текущего элемента

		for (size_t l = k + 1; l < sizeof(arr) / sizeof(arr[0]); l++)
		{
			if (arr[l] > arr[indexMax]) //если элемент больше максимального, то запоминаем его индекс
			{
				indexMax = l;
			}
		}

		temp = arr[k];
		arr[k] = arr[indexMax];
		arr[indexMax] = temp;
	}

	std::cout << "\n";
	std::cout << "With sorting: ";

	for (size_t z = 0; z < sizeof(arr) / sizeof(arr[0]); z++)
	{
		std::cout << arr[z] << " ";
	}
	}
#endif
	stop
// *******************************************************
//Задание 6.
#if 0
//Объявите встроенный одномерный массив, состоящий из N элементов целого типа. 
//Напишите фрагмент кода, который вводит целые числа с помощью
//потока ввода в объявленный Вами массив, каждый раз ( на каждой итерации!)
//упорядочивая полученное значение по возрастанию.
//Для проверки выводите массив на консоль на каждой итерации`

	const int N = 5;
	int arr[N];

	for (int i = 0; i < N; i++)
	{
		std::cout << "Enter [" << i << "] number to fill the array: ";
		std::cin >> arr[i];

		int temp = arr[i]; //запоминаем обрабатываемый элемент
	
		for (int j = i - 1; j >= 0 && arr[j] > temp; j--)
		{
			temp = arr[j + 1];
			arr[j + 1] = arr[j];
			arr[j] = temp;
		}

		for (int ii = 0; ii <= i; ii++)
		{
			std::cout << arr[ii] << " ";
		}
		std::cout << std::endl;
	}
#endif
	stop
// *******************************************************
//Задание 7. 
#if 0
//Простой поиск.
//Модифицируйте предыдущее задание следующим образом:
//очередное введенное значение помещается в массив только при условии, 
//что там еще такого нет (то есть дубли игнорируются)

	const int N = 5;
	int arr[N];

	for (int i = 0; i < N; i++)
	{
		std::cout << "Enter [" << i << "] number to fill the array: ";
		std::cin >> arr[i];

		int temp = arr[i]; //запоминаем обрабатываемый элемент

		bool fl = false;
		for (int j = 0; j < i; j++)
		{
			if (arr[i] == arr[j])
			{
				fl = true;
				break;
			}
		}
		// Проверка на повторы!!!

		if (fl) {
			i--;
			continue;
		}


		for (int j = i - 1; j >= 0 && arr[j] > temp; j--)
		{
			temp = arr[j + 1];
			arr[j + 1] = arr[j];
			arr[j] = temp;
		}

		for (int ii = 0; ii <= i; ii++)
		{
			std::cout << arr[ii] << " ";
		}
		std::cout << std::endl;
	}
#endif
stop
// *******************************************************
//Задание 8
#if 0
//Объявите одномерный встроенный массив элементов типа char.
//Сформируйте значения элементов массива с помощью генератора случайных 
//чисел таким образом, чтобы в массиве были только символы '*' и '_'  
//"сдвиньте звездочки" в начало массива, например:
//было - '*' '_' '_' '*' '*' '_' '*' '_' '*' '_'
//стало: '*' '*' '*' '*' '*' '_' '_' '_' '_' '_'
//и распечатайте массив 
//(Подсказки в файле Алгоритмы для лабораторной работы_4. pdf)

	srand(time(0));
	char arr[10] = {};
	int temp = 0;
	char s[] = { '*', '_' };
	char left = arr[0];
	char right = sizeof(arr) / sizeof(arr[0]) - 1;

	for (int i = 0; i < 10; i++)
	{
		arr[i] = s[rand() % 2];
		std::cout << arr[i] << ' ';
	}

	while(left < right)
	{
		if (arr[left] == '_') 
		{
			if (arr[right] == '*') 
			{
				temp = arr[left];
				arr[left] = arr[right];
				arr[right] = temp;
				left++;
				right--;
			}
			else 
			{
				right--;
			}
		}
		else 
		{
			left++;
		}
	}

	std::cout << "\n";

	for (int j = 0; j < sizeof(arr) / sizeof(arr[0]); j++)
	{
		std::cout << arr[j] << " ";
	}

#endif
	stop
// *******************************************************
//Задание 9
#if 0
//объявите одномерный встроенный массив  из N элементов и проинициализируйте его.
//а) сдвиньте все элементы массива вправо на 1 позицию
//б) (Циклическая перестановка). Сдвиньте все элементы массива вправо на 1 позицию, 
//но последний элемент не должен быть утерян. Его следут переместить в начало.
//например,  { 5, 2, 11, 4, 23, 9 } ->  {9, 5, 2, 11, 4, 23 }

//в)(Кольцевой буфер) выведите массив на печать, циклически "сдвинув" элементы вправо на 1 позицию.
// При решении задачи не следует перемещать элементы массива, а надо использовать кольцевой буфер.
// Одномерный массив можно "свернуть" в кольцо и считать, что за последним элементом следует начальный и
// потом установить "новое" начало массива.

	const int N = 6;
	int arr[N] = { 5, 2, 11, 4, 23, 9 };
	int s = sizeof(arr) / sizeof(arr[0]);
//А
#if 0
	for (int i = s - 1; i > 0; i--)
	{
		arr[i] = arr[i - 1];
	}

	for (int i = 0; i < s; i++)
	{
		std::cout << arr[i] << " ";
	}
	std::cout << std::endl;
#endif
//Б
#if 0
	int temp = arr[s - 1];

	for (int i = s - 1; i >= 0; i--)
	{
		arr[i] = arr[i - 1];

	}

	arr[0] = temp;

	for (int i = 0; i < s; i++)
	{
		std::cout << arr[i] << " ";
	}
	std::cout << std::endl;
#endif
//B
#if 0
	int shift = 1;

	for (int i = 0; i < s; i++)
	{
		std::cout << arr[((s - shift) + i) % s] << " ";
	}
	std::cout << std::endl;
#endif
#endif
	stop
// *******************************************************
//Задание 10 (*)
#if 0
//алгоритм "тасования колоды"
//объявите одномерный встроенный массив  из N элементов и 
// заполните  его неповторяющимися числами из заданного отрезка 
//натурального ряда, расположенными в случайном порядке
//(Подсказки в файле Алгоритмы для лабораторной работы_4.pdf)
//Алгоритм:
//Массив  A [N] инициализируется последовательными значениями из отрезка, например [0,N-1]
//index=N-1, где index- максимальное значение индекса.

//В цикле по index выполняется перемешивание значений:
//	1. Генерируется случайное число  R из отрезка [0, index]
//	2. Выполняется обмен значений A[index]  и  A[R]
//	3. index=index -1
//	4. Если index==0, то конец
//	5. Переход к шагу 1    

//Для того, чтобы выполнять это задание было интереснее, можно воспользоваться следующим массивом
// массив текстовых эквивалентов  достоинства карт

		const char* cards[] = { " 2\5", " 3\5", " 4\5", " 5\5", " 6\5", " 7\5", " 8\5", " 9\5", "10\5", " J\5", " Q\5", " K\5", " A\5",
			" 2\4", " 3\4", " 4\4", " 5\4", " 6\4", " 7\4", " 8\4", " 9\4", "10\4", " J\4", " Q\4", " K\4", " A\4",
			" 2\3", " 3\3", " 4\3", " 5\3", " 6\3", " 7\3", " 8\3", " 9\3", "10\3", " J\3", " Q\3", " K\3", " A\3",
			" 2\6", " 3\6", " 4\6", " 5\6", " 6\6", " 7\6", " 8\6", " 9\6", "10\6", " J\6", " Q\6", " K\6", " A\6",
	};
#endif
	stop

//*********************   Дополнительное задание   ****************************************************
//Задание 11 (*)  
// Выполните задания 3 и 4 по курсовой работе 
// описание заданий находится в файлах "Задание (игра Змейка)_3 (одномерные массивы)_3.docx" и 
// "Задание (игра Змейка)_4 (+еда)_3.docs"
// Каждое задание выполняется в отдельном проекте
// Рекомендация:
// Все проекты (project), связанные с курсовой работой имеет смысл помещать в одно решение (solution)
//*****************************************************************************************************

}