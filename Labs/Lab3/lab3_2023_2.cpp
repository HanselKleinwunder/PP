/*************************************************************
	Практическое занятие №3. Директивы препроцессора.
							Указатели.
*************************************************************/

#include "stdafx.h"


#define	  stop __asm nop	//с помощью директивы препроцессора задаем
							//макроподстановку

int _tmain()
{
//Задание 1. Директивы препроцессора
#if 0

// ********************************************************

//1.1. Использование "математических" макросов стандартной библиотеки:
//в заголовочном файле <cmath> (который в свою очередь включает старый
//файл math.h) определены часто используемые математические
//константы, например M_PI. Воспользуйтесь этой константой для
//вычисления длины окружности.
//Обратите внимание: определения констант в свою очередь тоже заключены
//в директивы условной трансляции. Что еще, кроме подключения заголовочного
//файла, требуется сделать???

#endif
//Задание 1.2.1
#if 0

// *******************************************************
//1.2.Макросы с параметрами.
//1.2.1 Напишите свою макроподстановку LENGHT которая вычисляет длину окружности.
// протестируйте написанный макрос для следующих ситуаций:
	{
#define LENGHT(lenght) ((lenght)*2*M_PI)

		float l1 = LENGHT(1 + 2); // должно быть 18.8495...
		float l2 = 1 / LENGHT(2); // должно быть 0.07957...
		stop

    }

#endif
//Задание 1.2.2
#if 0

// *******************************************************
//1.2.2 (B) определите макрос MAX(A, B)  для вычисления б'ольшего
//значения из двух.
	
//Используйте макрос следующим образом. Следите за изменением
//значений переменных k, i, j. Объясните результат.
//Постарайтесь убрать побочные эффекты.
//Отметьте случаи, когда избежать побочных эффектов невозможно

#define MAX(A,B) ((A > B) ? A : B)

	int i = 10, j = 12, k;
	k = MAX(i, j); 			//  i = 10  j = 12  k = 12 //12 больше, чем 10
	k = MAX(j, i) * 2;		//  i = 10  j = 12  k = 24 //большее значение умножили на 2, т.е. 12 * 2 = 24
	k = MAX(j, i+3);		//  i = 10  j = 12  k = 13 //13 больше, чем 12. Изначально к 10 прибавили ещё 3. В итоге, 12 меньше
	k = MAX(i--, j++);		//  i = 9  j = 13  k = 14
							//Здесь постфикс, а значит, и инкремент, и декремент происходят после вычисления выражения.
							//В итоге всё равно переменная j больше, т.к. на момент вывода в этой переменной будет 12
							//После инкремента должно получиться 13, но отладчик указывает на 14.
	k = MAX(--i, ++j); //Теперь используются префиксные операторы, а значит сначала выполнятся они, а потом вычисление

#endif			
//Задание 1.2.3
#if 0

// *******************************************************
//1.2.3 определите макрос EXCHANGE(X, Y)  для перестановки
//двух объектов типа int в памяти местами. Проверьте для приведенного
//фрагмента. Подумайте, что будет делать макроподстановка, если
//переставляемые значения разного типа??? 
#define EXCHANGE(X,Y) int Z = X; X = Y; Y = Z; //сделать через третью переменную

	int x1 = 1, y1 = -1;
	EXCHANGE(x1,y1);

	int x2=100, y2=-100;
	EXCHANGE(x2,y2);

	//Если значения разного типа, то возможна потеря данных. Но если смотреть по отладчику, то он их не переносит

#endif
//1.3. Директивы условной трансляции
#if 0

// *******************************************************
//Выполняя следующий фрагмент, посмотрите, какое
//значение принимает переменная iNN. Что нужно сделать
//для того, чтобы результат был равен 0? 1? 2?
//Когда ни одна из переменных не объявлена, то переменная "iNN" принимает значение -1.

	int iNN;
//#define NNN
//#define MMM
//#if defined NNN && defined MMM
//	iNN = 0;
//#endif
//
//#define MMM
//#if defined MMM
//	iNN = 1;
//#endif
//
//#define NNN
//#if defined NNN
//	iNN = 2;
//#endif
#endif
#if 0
	int iNN;
#if defined NNN && defined MMM
	iNN = 0;
#elif defined MMM
	iNN = 1;
#elif defined NNN 
	iNN = 2;
#else
	iNN = -1;
#endif
	
	stop
#endif
//Задание 1.4.
#if 0

// *******************************************************
//Задание 1.4. Загляните в Project -> Properties -> диалоговая панель
//- Property Pages -> C\C++  -> Preprocessor -> Preprocessor definitions.
//В опциях командной строки в зависимости от мишени сборки проекта
//(Debug или Release) может быть определено с помощью ключа /D
//имя _DEBUG. С помощью директив условной
//трансляции напишите фрагмент кода, который в зависимости от типа
//мишени выводит с помощью cout разный текст на консоль. Проверьте при разных мишенях сборки.

//Пусть
//для мишени Debug в процессе выполнения данного участка
//кода на экран выводится информация об
//имени файла, номере строки с функцией вывода, дате и времени 
//компиляции файла, содержащего данную функцию вывода,
//а также имя функции, содержащей данную строку.

//Для мишени Release должна быть просто выведена строка
//"Release configuration!"

//Подсказка: для получения нужной информации зайдите в online справку
//(Help -> View Help), выберете язык C++ и в поле поиска введите 
//следующую ключевую фразу: Predefined Macros
// Или пройдите по ссылке: https://docs.microsoft.com/en-us/cpp/preprocessor/predefined-macros?view=msvc-160

#if defined _DEBUG
		std::cout << "Debug configuration!" << std::endl;
		std::cout << "File name: " << __FILE__ << std::endl;
		std::cout << "Number line: " << __LINE__ << std::endl;
		std::cout << "Date: " << __DATE__ << std::endl;
		std::cout << "Time: " << __TIME__ << std::endl;
#else
		std::cout << "Release configuration!" << std::endl;
#endif

#endif
//Задание 1.5
#if 0

// *******************************************************
//Задание 1.5  Управляя определенностью идентификатора _UNICODE и используя
//возможности заголовочного <tchar.h>, определим и проинициализируем переменную,
//которая может становиться как однобайтовой, так и расширенной без 
//изменения исходного текста.
//С помощью отладчика проверьте результат (определите значение в 10-чной и 16-чной системе счисления).

//Подсказка: Для того, чтобы настроить проект на работу с  некоторой кодировкой, надо:
//1)Выбрать Project -> Properties. Будет открыта диалоговая панель  Property Pages  
//2)Configuration Properties -> Advansed-> Advansed Properties -> Character Set
//3) установить флаг "Use Unicode Character Set", если требуется Unicode
//4) установить флаг "Not Set", если требуется  работа с однобайтовыми символами.
//Замечание:  В следующие 4 строки не надо вносить никаких изменений, только добавить комментарии 
// В комментариях указать значения кодов символов в 10-чной и 16-чной системе счисления

	{
		TCHAR ch1 = __T('A');	  // ch1 = 65, 0x0041 'A'
		size_t s1 = sizeof(ch1); // s1 = 2, 0x00000002
		TCHAR ch2 = __T('Ф');	// ch2 = 1060 'Ф', 0x0424 'Ф'
		TCHAR ch3 = 'Ф';       // ch3 = 65492, 0xffd4
	}

#endif
//Задание 1.6. Создание файла предкомпиляции
#if 0

// *******************************************************
//Задание 1.6
//Создайте файл предкомпиляции.
//Особого смысла в этой простой лаб. работе это не имеет.
//Задание предлагается для знакомства с техникой создания файла предкомпиляции

//В случае нашей лабораторной работы можно поместить директивы препроцессора, 
//подключающие библиотечные файлы в отдельный заголовочный файл и создать файл предкомпиляции.
//По умолчанию при создании нового проекта в Visual Studio в проекте указывается имя stdafx.h(VS 2019) 
// в качестве имени файла предкомпилированного заголовка. Имя этого файла может быть изменено, но с целью упрощения мы этого делать не будем.
//Надо выполнить несколько шагов :
//1) Создать файл stdafx.h и поместить в него заголовки библиотечных файлов, которые будут использованы в работе
//2) Создать файл реализации stdafx.cpp  и в него поместить единственную строку   #include "stdafx.h" 
//3) В клиентском файле с исходным кодом подключить заголовочный файл stdafx.h
//4) Задать ключи для файлов реализации :
//		для stdafx.cpp - / Yc
//		для lab3.cpp - / Yu
	{

	}

#endif
//Задание 2. Заголовочные файлы. Директива #include
#if 0

// ********************************************************
	//Задание 2.Заголовочные файлы. Директива #include
	//Создайте и подключите к проекту два заголовочных файла 1.h и 2.h
	//В каждом заголовочном файле объявите перечисление с одинаковыми именами
	//констант, но сопоставьте именованным константам разные значения, например:
	//1.h - enum MyEnum{My1, My2, My3};  . 2.h - enum MyEnum{My1=5, My2, My3};
	//С помощью директив условной трансляции в DEBUG-версии пользуйтесь значениями
	//констант из 1.h, а в RELEASE-версии значениями констант из 2.h

#define _DEBUG

#if defined _DEBUG
#include "1.h"
#else
#include "2.h"
#endif
	MyEnum one = My1;
	MyEnum two = My2;
	MyEnum three = My3;

	std::cout << one << std::endl;
	std::cout << two << std::endl;
	std::cout << three << std::endl;

#endif
//Задание 3. Указатели
#if 0

// ********************************************************
//Объявите  несколько объектов разных типов и проинициализируйте их.
//Объявите указатели соответствующих типов и проинициализируйте их
//адресами заданных объектов. 
//Выполняя задание, с помощью отладчика посмотрите, какие значения
//будут присвоены переменным-указателям и на что эти указатели
//"указывают"

	int x = 2;
	char y = 'b';

	int* p = &x; //&x	0x0113f7d0 {2}	int *
	char* t = &y; //&y	0x0136fb73 "bÌÌÌÌÌÌÌÌ\x2"	char *


#endif
//Задание 4. Арифметика указателей. Операция разыменования указателя.
#if 0

// *******************************************************
//Выполняя задание, следите за изменением значений
//указателей и значений объектов, на которые они указывают.
//Интерпретируте наблюдаемые результаты

	{
		int nAr[3] = {1,3}; //массив на 3 элемента. nAr	0x00dffb44 {1, 3, 0}

		int* pn = &nAr[0]; //Указатель на массив nAr, а именно на элемент под ячейкой 0. &nAr[0]	0x00dffb44 {1}	int *

		(*pn)++;	//Постфиксный инкремент указателя. 	*pn	2	int. После этого в массиве будут находиться значения: {2, 3, 0}, т.к. идёт инкремент значения под индексом 0.
		pn++;	//		pn	0x00dffb48 {3}	int *.

		char cAr[]={'A','B','C','D'}; // cAr	0x00dffb2c "ABCD...	char[4].
		char* pc = &cAr[0]; // &cAr[0]	0x00dffb2c "ABCDÌÌÌÌÌÌÌÌHûß"	char *. Указатель на значение массива под индексом 0.

		(*pc)=(*pc)+5;	// *pc	70 'F'	char. Здесь будет указатель на элемент массива под индексом 0.
		pc=pc+3;	//+		pc	0x00dffb2f "DÌÌÌÌÌÌÌÌHûß"	char *. Здесь будет указатель на элемент массива под индексом 2.
	
		double dAr[3]={1.0,2.0}; //	dAr	0x00dffb00 {1.0000000000000000, 2.0000000000000000, 0.0000000000000000}	double[3].

		double* pd1 = &dAr[0]; //&dAr[0]	0x00dffb00 {1.0000000000000000}	double *.
		double* pd2 = pd1; //*pd2	1.0000000000000000	double. Указателю pd2 присваиваем значение указателя pd1.

		(*pd2)+=2; //*pd2	3.0000000000000000	double.

		pd2+=2;

		//Объясните результат выполнения операции
		//вычитания двух указателей
		pd1 = &dAr[0];			// pd1	0x00dffb00 {3.0000000000000000}	double *.

		pd2 = &dAr[1];			// pd2	0x00dffb10 {2.0000000000000000}	double *.

		int nNumber=pd2 - pd1;  // nNumber	1	int. Скорее всего, показывает расстояние от элемента под индексом 0 и элементом под индексом 1.

		//Сравните указатели pd2 и pd1 и с помощью cout
		//выведите результаты сравнения.

		if (pd2 > pd1) 
		{
			std::cout << "pd2" << std::endl;
		}
		else if (pd2 < pd1) 
		{
			std::cout << "pd1" << std::endl;
		}
		else 
		{
			std::cout << "pd2 == pd1" << std::endl;
		}

		stop
	}

#endif
//Задание 5. Void-указатель.
#if 0

// *******************************************************
//5.1. Выполняя задание, посмотрите - какие значения присваиваются
//void-указателю. Обратите внимание: средствами отладчика Вы
//не можете посмотреть значения, на которые "указывает"
//void-указатель

	void*	pVoid;	//объявление void-указателя
	int	nObject3=5;
	char cObject3='A';
	int*	pInt = &nObject3;//&nObject3	0x00d3f6e0 {5}	int *
	pVoid=&nObject3; //5
	pVoid=&cObject3; //cObject3	65 'A'	char
	pVoid=pInt;//pInt	0x008ff8d8 {5}	int *

	
//Прежде, чем раскомментировать следующую строчку, вспомните:
//что нужно сделать, чтобы выражение стало корректным 	
	pInt= static_cast<int*>(pVoid);

#endif
//Задание 5.2. Void-указатель.
#if 0
// *******************************************************
//5.2. При выполнении следующего фрагмента посмотрите, какие неприятности
//могут Вас ожидать при явном приведении типа void-указателя,
//который в момент времени (1) указывает на double, к типу 
//указателя на int (2) 

	void* pVoid;
	double dObject3 = 33.33;
	pVoid = &dObject3;	//dObject3	33.329999999999998	double


	int nTmp = *(static_cast<int*>(pVoid)); //Половина значения отбросится
	int nTmp2 = *(static_cast<int*>(pVoid));
	stop

#endif
//Задание 6. Void-указатель.
#if 1
// *******************************************************
//Задание 6.При выполнении задания обратите внимание на то,
//как наглядно отладчик "раскрывает" конструкции типа
//"указатель на указатель" и на способы получения конечного
//объекта по таким "иерархическим" указателям

	int	n1=1;

//Объявите указатель pn и проинициализируйте его так, чтобы он
//"указывал" на n1
	int* pn = &n1;

//Объявите указатель ppn и проинициализируйте его так, чтобы он
//"указывал" на pn
	int** ppn = &pn;


//Объявите указатель pppn и проинициализируйте его так, чтобы он
//"указывал" на ppn
	int*** pppn = &ppn;

  
//С помощью указателей pn, ppn и ppn получите значение объекта n1
//и присвойте его n2

	int n2 = *pn;
	int n2 = **ppn;
	int n2 = ***pppn;

	stop

#endif
//Задание 7 (*). Курсовая
#if 0
//*********************   Дополнительное задание   ****************************************************
//Задание 7 (*)  
// Выполните задание 2 по курсовой работе 
// описание задания находится в файле "Задание (игра Змейка)_2 (змейка на экране)_3.docx"
// Каждое задание выполняется в отдельном проекте
// Рекомендация:
// Все проекты (project), связанные с курсовой работой имеет смысл помещать в одно решение (solution)
//*****************************************************************************************************
#endif
	return 0;
}//end main